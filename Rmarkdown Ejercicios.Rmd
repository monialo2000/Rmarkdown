---
title: "RMarkdown cap 27 y 28"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(datos)

pequenios <- diamantes %>%
  filter(quilate <= 2.5)
```

# Rmarkdown
Tenemos datos respecto de `r nrow(diamantes)` diamantes. Únicamente 
`r nrow(diamantes) - nrow(pequenios)` son mayores a 2,5 quilates. 

La distribución de los diamantes pequeños se muestra a continuación:

```{r, echo = FALSE}
pequenios %>%
  ggplot(aes(quilate)) +
  geom_freqpoly(binwidth = 0.01)
```
## Render: 
Para producir un reporte completo que contenga todo el texto, código y resultados, clic en “Knit” o presiona Ctrl + Shift + K. Puede hacerse también de manera programática con rmarkdown::render("1-example.Rmd").

## Knit: Con las opciones de Knit se puede variar el tipo de salida (HTML, PDF, Word)

Cuando haces knit al documento, R Markdown envía el .Rmd a knitr que ejecuta todos los bloques de código y crea un nuevo documento markdown (.md) que incluye el código y su output. El archivo markdown generado por knitr es procesado entonces por pandoc que es el responsable de crear el archivo terminado.

![Flujo] (C:/Users/M-C/Documents/Certificacion/cheatsheets/Rmarkdown/Rmarkdown/Flujo RmdKnitPandoc.JPG)

Formato de texto
------------------------------------------------------------

*cursiva*   o _cursiva_
**negrita**   __negrita__
`code`
superíndice^2^ y subíndice~2~

**Para provocar salto de linea basta con tipear 2 espacios**

Encabezados
------------------------------------------------------------

# Encabezado de primer nivel

## Encabezado de segundo nivel

### Encabezado de tercer nivel

Listas
------------------------------------------------------------

*   Elemento 1 en lista no enumerada

*   Elemento 2

    * Elemento 2a

    * Elemento 2b

1.  Elemento 1 en lista enumerada

1.  Elemento 2. La numeración se incrementa automáticamente en el output.

Enlaces e imágenes
------------------------------------------------------------
![Problemas carga Flujo Rmarkdown](FlujoRmdKnitPandoc.jpg)

si la imagen se encuentra al posicionarse encima, aparece la imagen como grisada

![logo_github](https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png){width='100px'}

Dentro de los corchetes, se puede escribir el texto alternativo. Este es opcional y solo entra en acción cuando no se puede cargar la imagen correctamente.

<http://ejemplo.com>

[texto del enlace](http://ejemplo.com)

## faltaría agregar otra forma como se hace en HTML, con un bloque <....>


Tablas 
------------------------------------------------------------

Primer encabezado     | Segundo encabezado
--------------------- | ---------------------
Contenido de la celda | Contenido de la celda
Contenido de la celda | Contenido de la celda

# Tabla ascii imagen
![](C:/Users/M-C/Tabla_Ascii.jpg)

## Bloques (Chunks)


Para insertar un chunk de código se puede hacer con alt+ctrl+i o bien con el símbolo insert cuadradito c en verde, y con  la flecha se puede elegir lenguaje, o también manualmente tipeando ```{r} y ```

Dentro del chumk sepuede ejecutar como antes con ctrl + enter... pero también esta el atajo ctrl+shift+enter que ejecuta todo el chunk.

El encabezado de bloque, consiste en ```{r, seguido por un nombre opcional para el bloque, seguido luego por opciones separadas por comas y un }. Luego el código y al final ´´´
Hay un chunk especial llamado setup: cuando te encuentras en modo Notebook, el bloque llamado setup se ejecutará automáticamente una vez, antes de ejecutar cualquier otro código.

## Opciones dentro de Bloques

Veremos las más importantes, el resto se puede encontrar en <http://yihui.name/knitr/options/>
Estos, controlan si tu bloque de código es ejecutado y qué resultados estarán insertos en el reporte final:

* eval = FALSE no se evalua el código y por ende no se ejecutará. Sirve por ejemplo para mostrar código como ejemplo o deshabilitar un bloque sin #.

* include = FALSE ejecuta el código, pero no muestra el código ni los resultados en el documento final. Se usa para configuración, por ejemplo se incluyen library()...

* echo = FALSE evita que el código se vea, pero muestra los resultados. Se usa mucho para usuarios finales q no quieren ver código.

* message = FALSE o warning = FALSE, evita que aparezcan mensajes o advertencias en el documento final.

* results = 'hide' oculta output impreso; fig.show = 'hide' oculta gráficos.

* error = TRUE **causa que el render continúe aunque el código devuelva error. En general no se incluye en el código final, pero puede ser muy util para depurar código. Tambien es útil si quieres incluir un error al enseñar. Por default error = FALSE provoca el el knit falle incluso si hay error en documento**.

Para lista completa de opciones en <http://yihui.name/knitr/options/>



|Opción            | Ejecuta |	Muestra	|   Output	|  Gráficos	|  Mensajes |	Advertencias |
|------------------|---------|----------|-----------|-----------|-----------|--------------|
| eval = FALSE     |   -     |     		  |    -      |   	-     |   	-	    |       -      |
| include = FALSE	 |    	   | -        |    -      |   	-	    |     -   	|       -      |
| echo = FALSE	   |     		 | -		    |           |           |           |              |
| results = "hide" |         |          |    -      |           |           |              |			
| fig.show = "hide"|         |          |           | 		-	    |           |              |	
| message = FALSE  |         |          |           |           | 		-	    |              |
| warning = FALSE  |         |          |           |           |           |				-      |

 collapse = TRUE muestra el block de fuente y de Output en un sólo bloque, si FALSE (es el default) lo muestra separado.                       **solo aplica para Markdown docs**.


## Tablas y Graficos:
Por defecto, R Markdown imprime data frames y matrices tal como se ven en la consola:

```{r tablas, echo = FALSE}
mtcars[1:5, ]

```
pero si se quiere con otro formato, se puede utilizar la función kable de knitr:
```{r kable, echo FALSE}
knitr::kable(
  mtcars[1:5, ],
  caption = "Un kable de knitr."
)
```

?knitr::kable para ver los otros modos en los que puedes personalizar la tabla. Sino indagar en los paquetes: **xtable, stargazer, pander, tables y ascii**. Cada uno provee un set de herramientas para generar tablas con formato a partir código de R.
En Markdown el párrafo que inicia con >  lo hace un **bloque de cita**. si además queremos un píe de cita alineado a derecha se puede generar con tuffle::quote_footer() en una expresión inline  por ejemplo:

> Citas:  
> Al Pan, pan... y al vino,vino 
> No por mucho madrugar amanece más temprano
> `r tufte::quote_footer(' Autor Anonimo')`

**Para quote individuales usar acento al revés alrededor de la palabra o frase que se quiere destacar**.     

## Redimensionar graficos en Rmarkdown 

Hay cinco opciones principales que controlan el tamaño de la figura: `fig.width`, `fig.height`, `fig.asp`, `out.width` y `out.height`. El tamaño de la imagen es un desafío porque hay dos tamaños (el tamaño de la figura creada por R y el tamaño al que se inserta en el documento de salida) y varias formas de especificarlo (es decir, altura, ancho y relación de aspecto: elige dos de tres). Estas son tres de las cinco:

* que los gráficos tengan un ancho consistente, se puede configurar: `fig.width = 6` (6 ") y `fig.asp = 0.618` (la proporción áurea) en los valores predeterminados. Luego, en bloques individuales, solo ajusto `fig.asp`.

* Controlo el tamaño de salida con `out.width` y lo configuro a un porcentaje del ancho de línea).De manera predeterminada, out.width = "70%" y fig.align = "center"

* Para poner múltiples gráficos en una sola fila, establezco out.width en 50% para dos gráficos, 33% en 3 gráficos, o 25% en 4 gráficos, y setfig.align = "default".

Si observas que tienes que entrecerrar los ojos para leer el texto de tu gráfico, debes ajustar fig.width. Si fig.width es mayor que el tamaño de la figura en el documento final, el texto será demasiado pequeño; si fig.width es más pequeño, el texto será demasiado grande. A menudo necesitarás experimentar un poco para calcular la proporción correcta entre fig.width y el ancho asociado en tu documento. 

Si deseas asegurarte que el tamaño de fuente es el mismo en todas tus figuras, al establecer out.width, también necesitarás ajustar fig.width para mantener la misma proporción en relación al out.width predeterminado. Por ejemplo, si tu valor predeterminado de fig.width es 6 y out.width es 0.7, cuando establezcas out.width = "50%" necesitarás establecer fig.width a 4.3 (6 * 0.5 / 0.7).

### Otras opciones importantes

1. configurar `fig.show = "hold"` para que los gráficos se muestren después del código

1. Para agregar un título al gráfico, usa fig.cap. En R Markdown esto cambiará la figura de “inline” a “floating”.

1. Si estás produciendo resultados en formato PDF, el tipo de gráficos predeterminado es PDF, es bueno porque son graficos vectoriales de alta calidad. Pero puede ser muy grande la figura, entonces se puede configura `dev = "png"` para forzar el uso de PNG. Son de calidad ligeramente inferior, pero serán mucho más compactos.

1. darles nombres a los bloques de código que producen figuras. Etiquetar el bloque se utiliza para generar el nombre de archivo del gráfico en el disco, por lo que darle un nombre a los bloques hace que sea mucho más fácil seleccionar gráficas y reutilizarlas.

## Caching: 
Si tienes cómputos que toman mucho tiempo, quiza no quieras empezar desde cero a procesar los bloques de codigo (aunque es muy bueno para la reprodcibilidad del documento). En ese caso, la solución es `cache = TRUE`. Guarda el output  del bloque en un archivo con un nombre especial en el disco. En ejecuciones siguientes, knitr revisará si el código ha cambiado, y si no ha hecho, reutilizará los resultados del caché. Pero por default no controla dependencia:por ejemplo si hay un chunk anterior que lea los datos a utilizar de disco. Para eso se utiliza la opción `dependson`. Knitr actualizará los resultados para el bloque cacheado cada vez que detecta que una de sus dependencias ha cambiado.  **A tener en cuenta: cache solo hace seguimiento de los cambios dentro del archivo .Rmd**. Para seguir también los cambios hechos en ese archivo, puedes usar la opción `cache.extra`.

Acordarse de limpiar  todos los cachés con `knitr::clean_cache()`.

El siguiente chunk se definió con cache.extra = file.info("un_archivo_muy_grande.csv"), y eval FALSE solo para poder usar a fines didácticos, para que no se evalue y trate de leer.

```{r datos_crudos, cache.extra = file.info("un_archivo_muy_grande.csv"), eval = FALSE}
datos_crudos <- readr::read_csv("un_archivo_muy_grande.csv")
```

## Opciones globales

`knitr::opts_chunk$set()`  para setear opciones y no dejar las default. ** Se puede incluir en el chunk de setup**  
Por ejemplo para tutoriales o libros usamos el sig. parrafo de global options, que utiliza nuestro formato preferido de comentarios y se asegura que el código y el output se mantengan entrelazados:

>
>knitr::opts_chunk$set(  
>  comment = "#>",  
>  collapse = TRUE  
>)

Esto ocultará por defecto el código, así que solo mostrará los bloques que deliberadamente has elegido mostrar (con echo = TRUE). Puedes considerar fijar message = FALSE y warning = FALSE, pero eso puede hacer más díficil la tarea de depurar problemas, porque no verías ningún mensajes en el documento final.

> knitr::opts_chunk$set(
>  echo = FALSE
> )

Con este chunk vas a conseguir que no se muestre el fuente ejecutado, y si deliberadamente en alguno se quiere mostrar en ese chunk hay que agregar echo = TRUE

##Código R en linea de documento

Como ya vimos se puede insertar con `r nrow(diamantes)`. Cuando el resultado es un número se puede formatear usando la función format(). En este caso, definimos la función coma para que no tenga un número demasiado grande de decimales y el separador de miles con coma.

>coma <- function(x) format(x, digits = 2, big.mark = ",")
>coma(3452345)
>#> [1] "3,452,345"
>coma(.12358124331)
>#> [1] "0.12"

**HACER LOS EJERCICIOS DEL LIBRO DE ESTE TEMA QUE SON INTERESANTES**

## SOLUCIONANDO PROBLEMAS

Es más complicado en RMarkdown, porque al ejecutar no estas en un ambiente interactivo R.   

**Tips**:

 1. **Tratar de recrear el problema en una sesión interactiva.**  
 1. **Reinicia R, ejecuta todos los bloques de código. Si tienes suerte, eso recreará el problema y podrás descubrir lo que está ocurriendo interactivamente **  
 1. **Si lo anterior no ayuda, debe haber algo diferente entre nuestro ambiente interactivo y el ambiente de R Markdown -> hay que explorar sistemáticamente las opciones: La diferencia más común es el directorio de trabajo: el directorio de trabajo de R Markdown es el directorio en el que se encuentra: Revisar que el directorio de trabajo es el que esperas incluyendo getwd() en un bloque. **  
 1. **A continuación, piensa en todas las cosas que podrían causar el error. Necesitarás revisar sistemáticamente que tu sesión de R y tu sesión de R Markdown sean la misma. La manera más fácil de hacer esto es fijar error = TRUE en el bloque que causa problemas, y luego usa print() y str() para revisar que la configuración es la esperada. **  



